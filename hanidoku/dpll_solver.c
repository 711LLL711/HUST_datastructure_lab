#include "head.h"

ClauseNode* AddClause(ClauseNode* s, int var);        // 增加单子句
ClauseNode* IsUnitClause(ClauseNode* s);              // 判断是否存在单子句
ClauseNode* CopyS(ClauseNode* s);                     // 复制表
ClauseNode* CopyClause(ClauseNode* s);                // 复制一个子句
ClauseNode* DeleteClause(ClauseNode* s);              // 删除一个子句
ClauseNode* DeleteLiteral(ClauseNode* s, int var);    // 删除负变元
status Print(ClauseNode* s);                          // 打印表
status IsEmptyClause(ClauseNode* s);                  // 判断是否存在空子句
status RecordTruth(ClauseNode* s, int* truth_table);  // 记录单子句中元素的真值
status RemoveVar(ClauseNode* s, int var);             // 删除变元所在子句与负变元
int PickVar(ClauseNode* s);                           // 直接取第一个子句的第一个变元

status DpllSolver(ClauseNode* s, int* truth_table, int optimize)
//optimize为0表示优化前，1表示优化后
{
    ClauseNode* s_tmp = s;
    ClauseNode* unit_clause = IsUnitClause(s_tmp);    // 获得单子句

    // 单子句规则
    while (unit_clause)
    {
        RecordTruth(unit_clause, truth_table);  // 记录单子句中的变元的真值
        int var = unit_clause->right->data;
        RemoveVar(s, var);

        if (s->down == NULL) return FOUND;             // S为空
        else if (IsEmptyClause(s))   return NOTFOUND;  // S中存在空子句

        s_tmp = s;
        unit_clause = IsUnitClause(s_tmp);            // 还存在单子句则继续循环
    }

    // 分裂策略
    int var;
    if(optimize){//优化变元选择
        var = choose3(s); // 选变元
        //var = choose2(s);
    }else {
        var = PickVar(s);
    }
    if (DpllSolver(AddClause(CopyS(s), var), truth_table, optimize))  return FOUND;   // 变元的真值选对了,此处传入S的拷贝
    return DpllSolver(AddClause(s, -var), truth_table, optimize);                    // 变元的真值选错了
}

ClauseNode* CopyS(ClauseNode* s)
{
    ClauseNode* s_new, * c_tmp, * s_origin = s->down;

    // 创建root
    s_new = (ClauseNode*)malloc(sizeof(ClauseNode));
    s_new->right = NULL;
    c_tmp = s_new;

    // 循环创建子句
    while (s_origin)
    {
        c_tmp->down = CopyClause(s_origin);  // 复制整个子句
        c_tmp = c_tmp->down;                 // 下一个
        s_origin = s_origin->down;
    }
    return s_new;
}

ClauseNode* CopyClause(ClauseNode* s)
{
    ClauseNode* clause_tmp;
    LiteralNode* literal_tmp=NULL, * s_tmp = s->right;

    // 创建子句结点
    clause_tmp = (ClauseNode*)malloc(sizeof(ClauseNode));
    clause_tmp->down = NULL;
    clause_tmp->right = NULL;

    // 创建第一个文字结点
    if (s_tmp)
    {
        literal_tmp = (LiteralNode*)malloc(sizeof(LiteralNode));
        literal_tmp->data = s_tmp->data;
        literal_tmp->right = NULL;
        s_tmp = s_tmp->right;
        clause_tmp->right = literal_tmp;
    }

    // 循环创建之后的文字结点
    while (s_tmp)
    {
        literal_tmp->right = (LiteralNode*)malloc(sizeof(LiteralNode));
        literal_tmp->right->data = s_tmp->data;
        literal_tmp->right->right = NULL;
        literal_tmp = literal_tmp->right;
        s_tmp = s_tmp->right;
    }
    return clause_tmp;
}

ClauseNode* AddClause(ClauseNode* s, int var)
{
    ClauseNode* c_tmp;
    c_tmp = (ClauseNode*)malloc(sizeof(ClauseNode));
    c_tmp->right = (LiteralNode*)malloc(sizeof(LiteralNode));
    c_tmp->right->data = var;
    c_tmp->right->right = NULL;
    c_tmp->down = s->down;
    s->down = c_tmp;
    return s;
}

int PickVar(ClauseNode* s)
{
    //选取第一个文字--优化前
    int var = s->down->right->data;
    return var;
}

status RemoveVar(ClauseNode* s, int var)
{
    ClauseNode* c_tmp = s->down, * last_c_tmp = s;
    while (c_tmp)                                     // 循环读取每一个子句
    {
        c_tmp = DeleteLiteral(c_tmp, var);           // 删除子句里所有的负变元，如果遇到了正变元则返回NULL
        if (c_tmp == NULL)                            // 遇到了正变元
        {
            c_tmp = DeleteClause(last_c_tmp->down);  // 与正变元相同则删除子句
            last_c_tmp->down = c_tmp;
            continue;
        }
        if (c_tmp == NULL)   break;
        last_c_tmp = c_tmp;                          // 下一个子句
        c_tmp = c_tmp->down;
    }
    return OK;
}

ClauseNode* DeleteClause(ClauseNode* s)
{
    ClauseNode* c_tmp = s;
    LiteralNode* l;
    while (s->right)                     // 先删除子句中所有文字
    {
        l = s->right;
        s->right = s->right->right;
        free(l);
    }
    s = s->down;
    free(c_tmp);                        // 再删除空子句
    return s;
}

ClauseNode* DeleteLiteral(ClauseNode* s, int var)
{
    LiteralNode* l = s->right, * l_tmp;

    // 处理第一个文字
    if (l->data == -var)                  // 负变元
    {
        l_tmp = s->right->right;
        free(l);
        s->right = l_tmp;
        return s;
    }
    else if (l->data == var) return NULL; // 正变元

    // 循环处理接下来的文字
    while (l)
    {
        if (l->right && l->right->data == -var)
        {
            l_tmp = l->right;
            l->right = l->right->right;
            free(l_tmp);
        }
        else if (l->right && l->right->data == var)  return NULL;
        l = l->right;
    }
    return s;
}

status IsEmptyClause(ClauseNode* s)
{
    ClauseNode* c_tmp = s->down;
    while (c_tmp)
    {
        if (!c_tmp->right) return YES;
        c_tmp = c_tmp->down;
    }
    return NO;
}

status RecordTruth(ClauseNode* s, int* truth_table)
{
    int idx = abs(s->right->data) - 1;   // 序号=绝对值-1
    if (s->right->data > 0)  truth_table[idx] = 1;
    else    truth_table[idx] = 0;
    return OK;
}

ClauseNode* IsUnitClause(ClauseNode* s)
{
    ClauseNode* c_tmp = s;
    while (c_tmp)
    {
        if (c_tmp->right && !c_tmp->right->right)    return c_tmp;
        c_tmp = c_tmp->down;
    }
    return NULL;
}

status Print(ClauseNode* s)
{
    ClauseNode* c_tmp = s->down;
    LiteralNode* l_tmp;
    printf("\n-----Start-----\n");
    while (c_tmp)
    {
        l_tmp = c_tmp->right;
        while (l_tmp)
        {
            printf("%d ", l_tmp->data);
            l_tmp = l_tmp->right;
        }
        if (c_tmp->right)    printf("\n");
        else    printf("空\n");
        c_tmp = c_tmp->down;
    }
    printf("------End------\n");
    return OK;
}
